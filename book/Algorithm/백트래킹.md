# 백트래킹
<br>

> 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘

<br>

*DFS & BFS와 유사한 구조를 가진다*

<br>


### ✏ 백트래킹 기본 문제인 N과 M 문제를 통해 알아보자

<br>

#### `자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.`

#### `1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열`

<br>

N과 M을 3과 3이라고 했을 때, [1, 2, 3]을 이용하여 길이 3의 수열을 만들어야 한다.

만들 수 있는 수열은 총 6개가 된다.

- 1 2 3
- 1 3 2
- 2 1 3
- 2 3 1
- 3 1 2
- 3 2 1

과정을 보자면 *(⬜ = 빈칸)*

1 ⬜⬜ -> 1 2 ⬜ -> `1 2 3` -> 1 2 ⬜ -> 1 ⬜ ⬜

이런 식으로 길이가 3인 수열 `1 2 3`을 찾은 후 다시 돌아가야 한다.

즉, 재귀를 통해  ```append()```를 하고, `len(list) == 3`이 되면 `pop()`을 해주면서 돌아간다.

### 💻 코드

```python
def back():
    # 길이가 M이되면 순열을 출력 후 돌아가기 위해 return
    if len(lst) == M:
        print(*lst)
        return
    for i in range(1, N+1):
        if i not in lst:
            lst.append(i)
            # 재귀를 통한 반복
            back()
            # 끝 자리 제거
            lst.pop()
N, M = map(int, input().split())
lst = []
back()
```

### ❗주의점

1. 아무래도 재귀를 이용하다 보니 복잡한 문제인 경우에는 길을 놓치는 경우가 있다.

    이런 경우에는 `print`를 이용하면 편리하다.

2. 내가 했던 실수인데, 다른 문제에서 예제를 보면서 풀다가 M을 3으로 고정해놓고 풀었다.
    `if len(list) == 3:` 덕분에 무진장 틀렸다. 😂
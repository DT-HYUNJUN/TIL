# FE 면접 공부

## Javascript

### 1. 이벤트 동작 방식

- 이벤트 : 웹 페이지나 사용자가 수행하는 동작에 **반응**하여 발생하는 것들을 말한다.

- 이벤트 루프 : JS는 **단일 스레드** 기반 언어로 이벤트 루프를 통해 비동기 작업을 관리한다. 이벤트 루프는 콜백 큐에 있는 작업을 순차적으로 실행시키며, 이 과정에서 비동기 동작을 가능하게 한다.

- 이벤트 핸들링

  - 이벤트 리스너: 특정 이벤트가 발생했을 때 **실행될 함수**를 등록하는 것을 말한다. 이벤트 리스너를 통해 사용자의 동작에 반응하는 이벤트를 만들 수 있다.
  - 이벤트 객체: 이벤트가 발생할 때, **이벤트에 대한 정보를 담고 있는 객체**가 생성되는데, 이 객체를 통해 이벤트의 세부 정보에 접근할 수 있다.

- 이벤트 전파 : 이벤트가 전파되는 방식으로 `addEventListener()`의 세 번째 인자에 `true, false`에 따라 이벤트 전파 방식이 결정된다.

  - 이벤트 캡처링(`true`) : 이벤트가 발생했을 때, **가장 바깥쪽 요소에서부터** 시작하여 이벤트가 발생한 요소까지 이벤트가 전파되는 과정.
  - 이벤트 버블링(`false`) :** 이벤트가 발생한 요소에서 시작**하여 DOM 트리를 거슬러 올라가는 과정. 기본값이 버블링으로 되어있다.

### 2. var, let, const

- #### var
  - **중복 선언 가능**: `var`로 선원된 변수는 같은 스코프 내에서 중복 선언이 가능하다.
  - **함수 스코프**: `var`는 함수 스코프를 가진다. 함수 내에서 선언된 `var` 변수는 함수 내에서만 유효하며 함수 외부에서는 접근할 수 없다.
  - **호이스팅**: `var`로 선언된 변수는 호이스팅이 발생한다.
- #### let
  - **중복 선언 불가**: `let`으로 선언된 변수는 같은 스코프 내에서 중복 선언할 수 없다.
  - **블록 스코프**: `let`은 블록 스코프를 가진다. `{ }`로 둘러싸인 범위 내에서만 유효하며, 블록 외부에서는 접근할 수 없다.
  - **호이스팅 방지**: `let`으로 선언된 변수는 호이스팅이 발생하지 않는다.
- #### const
  - **재할당 불가**: `const`로 선언된 변수는 재할당이 불가능한다.
  - **블록 스코프**: `const`는 let과 마찬가지로 블록 스코프`{ }`를 가진다.
  - **호이스팅 방지**: `const`로 선언된 변수는 호이스팅이 발생하지 않는다.

### 3. 콜백 함수

콜백 함수는 **매개변수로 함수 객체**를 전달해서 **함수 내에서 매개변수 함수를 실행**하는 것을 말한다.

### 4. Promise 객체

Promise는 콜백 지옥을 탈출하기 위한 문법으로 비동기 작업의 최종 완료 또는 실패를 독자적인 객체다.

비동기 작업의 결과에 `.then()`이나 `.catch()`를 사용해 다음 작업을 이어서 사용할 수 있다.

### 5. async/await

async/await는 Promise를 기반으로 하는 비동기 처리 방식중 하나로, **비동기 코드를 동기 코드처럼 작성**할 수 있는 문법이다.

async는 함수 앞에 붙여 해당 함수가 비동기 함수임을 나타내고, await는 비동기 함수의 실행 결과를 기다리는 키워드다.

async 함수 안에서 await 키워드를 사용하면 해당 비동기 작업이 완료될 때까지 코드 실행을 멈추고 결과를 반환 까지 기다린다.

## React

### 1. React의 Life Cycle

- 리액트의 생명주기는 클래스 컴포넌트에서 주로 사용되며 마운트, 업데이트, 언마운트 세 가지 단계로 나뉜다.

1. 마운트
   - 마운트는 컴포넌트가 DOM에 삽입될 때의 단계를 말한다.
2. 업데이트
   - 업데이트는 컴포넌트가 업데이트 되는 과정을 다룬다. 새로운 props를 받거나, 내부 state가 변경될 때 발생한다.
3. 언마운트
   - 언마운트는 컴포넌트가 DOM에서 제거될 때 말한다.

### 2. 컴포넌트

- 컴포넌트는 리액트에서의 UI 요소를 구분하는 최소 단위다. 컴포넌트는 독립적으로 구성하여 재사용할 수 있고 이를 통해 새로운 컴포넌트를 만들 수 있다.

### 3. 렌더링 동작 방식

#### 1. DOM 트리 구축

- 브라우저가 서버로부터 **HTML 문서**를 모두 전달 받는다
- HTML 문서를 사용할 수 있는 구조로 변환하는 파싱을 통해 **파싱 트리**를 생성한다.
- 파싱 트리를 기반으로 DOM 요소와 속성 노드를 가지는 **DOM 트리**를 생성한다.

#### 2. CSSOM (CSS Object Model) 생성

- 1번과 같은 과정을 CSS에서도 실행한다.
- 그 결과로 브라우저가 이해하고 처리할 수 있는 형식(Style Rules)으로 변환한다.

#### 3. 렌더 트리 (DOM + CSSOM) 생성

- 브라우저는 DOM 트리를 기반으로 문서를 시각적인 구성 요소로 만들어주는 렌더 트리를 생성한다.

#### 4. 렌더 트리 배치

- 렌더링 트리는 위치와 크기를 가지고 있지 않기 때문에, 객체들에게 위치와 크기를 결정해준다.

#### 5. 렌더 트리 그리기

- 렌더 트리의 각 노드를 화면의 픽셀로 나타낸다.

- 렌더 트리 그리기가 완료되면, 화면에 콘텐츠가 표현된다.

## FE

### 1. CSR과 SSR의 차이

#### CSR (Client Side Rendering)

CSR은 클라이언트 쪽에서 렌더링을 한다는 뜻이다.

초기 로드 시 빈 HTML 템플릿과 모든 로직이 담겨있는 Javascript를 다운로드 하고

빈 HTML에 Javascript를 이용하여 DOM을 동적으로 생성하며 그려낸다.

1. 장점

   **트래픽 감소와 빠른 인터렉션**

   - Javascript를 사용해 동적으로 DOM을 그리기 때문에 원하는 내용만 업데이트가 가능하다.

   - CSR은 사용자의 행동에 따라 필요한 부분만 다시 읽어 들인다. 그레서 서버 측에서 전체 페이즈를 다시 읽어 들이는 것보다 빠른 인터렉션이 가능하다. 필요한 변경된 데이터만 받아올 수 있어 서버의 부담을 줄인다.

2. 단점

   **느린 초기 구동 속도**

   - CSR은 서버에서 View를 렌더링 하지 않는다. 그렇기에 HTML, Javascript, 각종 resources를 다운로드한 후에 브라우저에서 렌더링을 하기 때문에 초기 구동 속도가 느리다.

   **검색엔진 최적화(SEO)의 어려움**

   - CSR은 웹 페이지에서 view를 생성하기 위해 Javascript를 실행시켜야 한다. 하지만 대부분의 웹 크롤러는 Javascript파일을 실행시키지 못해 HTML에서만 콘텐츠들을 수집하게 되 CSR페이지를 빈 페이지로 인식하게 된다.

#### SSR (Server Side Rendering)

SSR은 서버에서 렌더링을 하는 방식이다.

클라이언트에서 요청할 때마다 각 상황에 맞는 HTML 파일을 넘겨준다.

1. 장점

   **빠른 초기 구동 속도**

   - SSR은 요청한 페이지의 HTML을 다운로드하기 때문에 CSR보다 초기 진입 시 로딩이 빠르다.

   **SEO 향상**

   - 서버에서 렌더링 후 개별 페이지를 넘겨받는 것이므로 각 페이지에 대한 정보를 입력하기 쉽기 때문에 CSR보다 SEO를 향상할 수 있다.

2. 단점

   **느린 페이지 이동 시간**

   - 링크 이동 시 부분 업데이트 하는 CSR과는 달리 SSR은 새로운 HTML을 받아오기 때문에 화면 깜빡임 현상이 존재한다. 그래서 초기 진입은 CSR보다 빠를지 몰라도 페이지 이동은 SSR이 더 느리다.

### 2. 웹 브라우저의 동작 방식

1. 브라우저에 웹 페이지 **URL 주소**를 입력한다.
2. URL 주소의 **도메인 네임**을 검색하고 일치하는 IP 주소를 찾아 URL 정보와 함께 전달한다.
3. 전달 받은 IP 주소와 URL 정보는 HTTP 프로토콜을 사용해 **HTTP 요청 메시지**를 생성한다.
4. HTTP 요청 메시지는 **TCP 프로토콜**을 사용해 인터넷을 거쳐 **해당 IP 컴퓨터로 전송**되고, 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 이용해 웹** URL 정보**로 변환한다.
5. 변환된 정보에 해당하는 테이터를 찾아내고 **HTTP 응답 메시지**를 생성하고 **TCP 프로토콜**을 사용해 사용자의 컴퓨터로 전송되고, 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 이용해 **웹 페이지 데이터**로 변환된다.
6. 변환된 데이터가 웹 브라우저에 나타나 사용자가 볼 수 있게 된다.

### 3. SPA

- SPA는 하나의 HTML 페이지를 기반으로 동적으로 컨텐츠를 변경하며 작동하는 웹 애플리케이션이다.

- 초기에 한 번의 페이지 로드만 필요하며 이후에는 필요한 데이터나 컨텐츠를 서버에서 가져와 화면을 업데이트 한다.

- UX가 좋고 웹 페이지 간의 전환 속도가 빠르지만, 초기 로드시 Javascript파일을 다운로드 하고 파싱해야 하므로 초기 로딩이 느릴 수 있다.

### 4. 동기식 비동기식

- #### 동기식
  - 한 작업이 실행되는 동안 다른 작업은 멈춘 상태를 유지하고 자신의 차례를 기다리는 방식을 말한다. JS가 동작하는 기본 원리이며 이러한 동작은 단일 스레드라고도 말한다.
  - JS의 엔진에는 함수의 호출이 담기는 **Call Stack**이 존재해서 요청된 작업들이 순차적으로 실행된다.
- #### 비동기식
  - 어떠한 요청을 보내면 그 요청이 끝날 때까지 기다리는 것이 아니라, 응답에 관계없이 바로 다음 동작이 실행되는 방식을 말한다.

### 5. 브라우저의 저장소

- #### 쿠키
  - 쿠키는 클라이언트와 서버의 연결이 끊겨도 필요한 정보를 기억하게 하기위해 서버에서 데이터를 묶어서 클라이언트의 컴퓨터 혹은 브라우져의 메모리에 저장되는 key value로 이루어진 작은 텍스트 파일이다.
- #### 세션 스토리지
  - 세션 스토리지는 새창, 새탭 단위로 생성되며 데이터를 공유하지 않는다. 독립적인 공간이므로 사용자가 브라우저를 닫거나 창을 닫으면 저장된 정보가 사라져 잠깐의 정보를 저장하기에 용이하다.
- #### 로컬 스토리지
  - 로컬 스토리지는 웹 도메인당 한 개씩 생성되며 새창, 새탭을 생성해도 웹 도메인만 같으면 데이터를 공유할 수 있다. 직접 로컬 스토리지를 삭제하지 않으면 영구적으로 데이터를 저장할 수 있다.

### 6. null과 undefined

- #### null
  - null은 원시값 중 하나로 어떤 값이 의도적으로 비어있음을 뜻한다. 또한 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 뜻한다.
- #### undefined
  - undefined는 개발자가 의도적으로 할당한 값이 아니라 JS 엔진에 의해 초기화된 값을 말한다.

### CORS

기본적으로 브라우저는 보안 정책인 **같은 출처에서만 리소스를 공유**하는 `SOP 정책`을 지키고 있다.

하지만 개발을 하다보면 다른 출처의 리소스를 사용하는 경우도 있는데 이런 경우는 CORS 정책을 지켜야 한다.

CORS(Cross-Origin Resource Shareing)는 출처가 다른 서버끼리 리소스를 주고 받을 때 보안을 위해 설정된 정책이다.

같은 출처인지, 다른 출처인지 확인하기 위해서는 URL에서 `프로토콜, 호스트, 포트`가 같은지 확인하면 된다. (ex. `https://www.myhost.com:8080`)

## 기타/직무관련

### 1. FE 개발을 하면서 기억에 남는 화면

### 2. 프로젝트에서 본인의 역할

### 3. FE 직무 선택 이유

### 4. 트러블 슈팅 경험
